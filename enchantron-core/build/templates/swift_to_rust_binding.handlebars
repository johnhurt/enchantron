
// This is an automatically generated file that lets a swift application
// bind to the rust library with a single method call

import Foundation
import CoreGraphics

class RustBinder {
  // Bind all the swift functions into rust
  class func bindToRust(_ systemInterop: SystemInterop) -> ApplicationContext {

    {{~#each types}}
    {{~#unless rust_owned}}

    // Type {{name}}
    {{~#each impls}}

    // Impl {{trait_name}}
    {{~#each functions}}
    {{~#unless override_default_behavior}}
    set_{{name}}({{name}})
    {{~/unless}}
    {{~/each}}
    {{~/each}}
    {{~/unless}}
    {{~/each}}

    return ApplicationContext(create_application(
        OpaquePointer(Unmanaged.passRetained(systemInterop).toOpaque())))
  }

}

// Wrapper classes for types owned by rust

{{~#each types}}
{{~#if rust_owned}}

// Type {{name}}

class {{name}} {

  private let ref: OpaquePointer?

  init(_ ref: OpaquePointer?) { self.ref = ref }
{{~#each impls}}

// Impl {{trait_name}}
{{~#each functions}}
{{~#if is_drop}}
  deinit {
    {{name}}(ref)
  }
{{else}}
  func {{lower_camel impl_name}}(
      {{#each arguments}}{{#unless @first}}, {{/unless}}{{lower_camel name}}: {{data_type.swift_name_internal}}{{/each}})
          {{#if return_type}}-> {{return_type.swift_name_internal}}{{/if}} {
    {{#if return_type}}return {{return_type.swift_type_coercion_prefix_incoming}}{{/if}}{{name}}(self.ref
        {{#each arguments}}, {{data_type.swift_type_coercion_prefix_outgoing}}{{lower_camel name}}{{data_type.swift_type_coercion_postfix_outgoing}}{{/each}}){{#if return_type}}{{return_type.swift_type_coercion_postfix_incoming}}{{/if}}
  }
{{~/if}}
{{~/each}}
{{~/each}}
}
{{~/if}}
{{~/each}}


// Define the functions for types owned by swift that will be called
// Externally by rust

{{~#each types}}
{{~#unless rust_owned}}

// Type {{name}}
{{~#each impls}}

// Impl {{trait_name}}
{{~#each functions}}
{{~#unless override_default_behavior}}
{{~#if is_drop}}

private func {{name}}(_self: OpaquePointer?) {
  let _ : {{type_name}} = Unmanaged.fromOpaque(UnsafeMutableRawPointer(_self!)).takeRetainedValue()
}
{{else}}

private func {{name}}(ref: OpaquePointer?
    {{#each arguments}}, {{lower_camel name}}: {{data_type.swift_name_incoming}}{{/each}})
        -> {{#if return_type}}{{return_type.swift_name_outgoing}}{{else}}Void{{/if}} {
  let _self : {{type_name}} = Unmanaged.fromOpaque(UnsafeMutableRawPointer(ref!)).takeUnretainedValue()

  {{#if return_type}}return {{return_type.swift_type_coercion_prefix_outgoing}}{{/if}}_self.{{lower_camel impl_name}}(
      {{#each arguments}}{{#unless @first}}, {{/unless}}{{data_type.swift_type_coercion_prefix_incoming}}{{lower_camel name}}{{data_type.swift_type_coercion_postfix_incoming}}{{/each}}){{#if return_type}}{{return_type.swift_type_coercion_postfix_outgoing}}{{/if}}

}
{{~/if}}
{{~/unless}}
{{~/each}}
{{~/each}}
{{~/unless}}
{{~/each}}


// Hidden, Stop-gap functions.  These functions are unsafe, so they shouldn't
// be called directly. They could allow for use after free bugs because they
// contain owned objects and mutable self references

// Create a string from a byte buffer. There isn't a way to create a String
// without copying the underlying data, so this method copies the data in the
// rust byte buffer and then the buffer is dropped like any other object
private func byteBufferToString(_ byteBuffer: ByteBuffer) -> String {
    let length = byteBuffer.getLength()
    let content = byteBuffer.getContent()
    let data = Data(
        bytesNoCopy: UnsafeMutableRawPointer(content!),
        count: Int(length),
        deallocator: .custom( { (_, _) in
            print("Dropping " + byteBuffer.description)
        }))

    return String(data: data, encoding: String.Encoding.utf8)!
}

// Create a CG data provider (texture data) from a rust byte buffer without
// copying the data. The byte buffer will be dropped after the CGDataProvider
// is. No copying occurs in this function, but once the data has been provided,
// the provider will be dropped since the data has to be copied to video ram in
// order to be useful
private func byteBufferToCGData(_ byteBuffer: ByteBuffer) -> CGDataProvider {
    let length = byteBuffer.getLength()
    let content = byteBuffer.getContent()!
    let byteBufferPointer = Unmanaged.passRetained(byteBuffer).toOpaque()

    return CGDataProvider(
        dataInfo: byteBufferPointer,
        data: content,
        size: Int(length),
        releaseData:

        { (pointer, _, _) in
        let _ =  Unmanaged<ByteBuffer>.fromOpaque(UnsafeRawPointer(pointer!)).takeRetainedValue()
        })!
}

// Cloning in swift without actually cloning the object, just its reference-
// counted pointer
private func clone(_ refToClone: OpaquePointer?) -> OpaquePointer? {
    let toClone = Unmanaged<AnyObject>.fromOpaque(UnsafeMutableRawPointer(refToClone!)).takeUnretainedValue()
    return OpaquePointer(Unmanaged.passRetained(toClone).toOpaque())
}